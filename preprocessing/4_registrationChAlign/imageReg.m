
function [MOVINGREG,regMethod, regScore] = imageReg(FIXED,MOVING, interp, shifts0)
%registerImages  Register grayscale images using auto-generated code from Registration Estimator app.
%  [MOVINGREG] = registerImages(MOVING,FIXED) Register grayscale images
%  MOVING and FIXED using auto-generated code from the Registration
%  Estimator app. The values for all registration parameters were set
%  interactively in the app and result in the registered image stored in the
%  structure array MOVINGREG.

% Auto-generated by registrationEstimator app on 14-May-2020
%-----------------------------------------------------------

if(nargin < 4)
    shifts0 = [0,0];
end

% Normalize FIXED image

% Get linear indices to finite valued data
finiteIdx = isfinite(FIXED(:));

% Replace NaN values with 0
FIXED(isnan(FIXED)) = 0;

% Replace Inf values with 1
FIXED(FIXED==Inf) = 1;

% Replace -Inf values with 0
FIXED(FIXED==-Inf) = 0;

% Normalize input data to range in [0,1].
FIXEDmin = min(FIXED(:));
FIXEDmax = max(FIXED(:));
if isequal(FIXEDmax,FIXEDmin)
    FIXED = 0*FIXED;
else
    FIXED(finiteIdx) = (FIXED(finiteIdx) - FIXEDmin) ./ (FIXEDmax - FIXEDmin);
end

% Normalize MOVING image

% Get linear indices to finite valued data
finiteIdx = isfinite(MOVING(:));

% Replace NaN values with 0
MOVING(isnan(MOVING)) = 0;

% Replace Inf values with 1
MOVING(MOVING==Inf) = 1;

% Replace -Inf values with 0
MOVING(MOVING==-Inf) = 0;

% Normalize input data to range in [0,1].
MOVINGmin = min(MOVING(:));
MOVINGmax = max(MOVING(:));
if isequal(MOVINGmax,MOVINGmin)
    MOVING = 0*MOVING;
else
    MOVING(finiteIdx) = (MOVING(finiteIdx) - MOVINGmin) ./ (MOVINGmax - MOVINGmin);
end

% Default spatial referencing objects
fixedRefObj = imref2d(size(FIXED));
movingRefObj = imref2d(size(MOVING));

[MOVINGREG, regMethod, regScore] = hybridreg(MOVING,movingRefObj,FIXED,fixedRefObj, interp, shifts0);
end


function [MOVINGREG, regMethod, regScore] = hybridreg(MOVING,movingRefObj,FIXED,fixedRefObj, interp, shifts0)
% function to try different registration methods and then ouput the best
% one's transformation
% improved version, 2020-06-06 by Jizhou Li

% five methods are evaluated, in all cases, only RIGID transformation (Translation and rotation) is
% considered and default parameters are used (generally should be enough).
% Thus feature based methods are excluded since they may introduce additional scaling.
%
% (1) phase correlation: imregcorr - Estimate geometric transformation that aligns two 2-D images using phase correlation
% (2) monomodal: see https://www.mathworks.com/help/images/ref/imregconfig.html
%    - similar brightness and contrast
% (3) multimodal: https://www.mathworks.com/help/images/ref/imregconfig.html
%   - different brightness and contrast, captured by different types of
%   devices or different exposure settings.
% (4) phase correlation + monomodal
% (5) phase correlation + multimodal

% (1) Phase correlation
tformPhaseCorr = imregcorr(MOVING,movingRefObj,FIXED,fixedRefObj,'transformtype','rigid','Window',false);
transformation{1} = tformPhaseCorr;
RegisteredImage{1} = imwarp(MOVING, movingRefObj, tformPhaseCorr, 'OutputView', fixedRefObj, 'SmoothEdges', true, 'FillValues', NaN, 'interp', interp);
if  contains(lastwarn, 'Resulting registration could be poor')
    score(1) = 0;
else
    % 2020-06-07 21:47:58 J.Li crop image first, since blank region will
    % break the evaluation
    [eval_reg,eval_fixed,~] = postcropping(RegisteredImage{1},FIXED);
    score(1) = ssim(eval_reg, eval_fixed);
end

lastwarn("");

% (2) monomodal
[optimizerMono, metricMono] = imregconfig('monomodal');
optimizerMono.GradientMagnitudeTolerance = 1.00000e-04;
optimizerMono.MinimumStepLength = 1.00000e-05;
optimizerMono.MaximumStepLength = 6.25000e-02;
optimizerMono.MaximumIterations = 100;
optimizerMono.RelaxationFactor = 0.500000;

% Align centers
% fixedCenterXWorld = mean(fixedRefObj.XWorldLimits);
% fixedCenterYWorld = mean(fixedRefObj.YWorldLimits);
% movingCenterXWorld = mean(movingRefObj.XWorldLimits);
% movingCenterYWorld = mean(movingRefObj.YWorldLimits);
% translationX = fixedCenterXWorld - movingCenterXWorld;
% translationY = fixedCenterYWorld - movingCenterYWorld;
translationX = shifts0(1);
translationY = shifts0(2);

% Coarse alignment
initTform = affine2d();
initTform.T(3,1:2) = [translationX, translationY];

% Apply transformation
tformMono = imregtform(MOVING,movingRefObj,FIXED,fixedRefObj,'rigid',optimizerMono,metricMono,'PyramidLevels',1,'InitialTransformation',initTform);
transformation{2} = tformMono;
RegisteredImage{2} = imwarp(MOVING, movingRefObj, tformMono, 'OutputView', fixedRefObj, 'SmoothEdges', true, 'FillValues', NaN, 'interp', interp);
if  contains(lastwarn, 'Resulting registration could be poor')
    score(2) = 0;
else
    [eval_reg,eval_fixed,~] = postcropping(RegisteredImage{2},FIXED);
    score(2) = ssim(eval_reg, eval_fixed);
end
lastwarn("");

% (3) multimodal
[optimizerMulti, metricMulti] = imregconfig('multimodal');
metricMulti.NumberOfSpatialSamples = 500;
metricMulti.NumberOfHistogramBins = 50;
metricMulti.UseAllPixels = true;
optimizerMulti.GrowthFactor = 1.050000;
optimizerMulti.Epsilon = 1.50000e-06;
optimizerMulti.InitialRadius = 6.25000e-03;
optimizerMulti.MaximumIterations = 100;

tformMulti = imregtform(MOVING,movingRefObj,FIXED,fixedRefObj,'rigid',optimizerMulti,metricMulti,'PyramidLevels',1,'InitialTransformation',initTform);
transformation{3} = tformMulti;
RegisteredImage{3} = imwarp(MOVING, movingRefObj, tformMulti, 'OutputView', fixedRefObj, 'SmoothEdges', true, 'FillValues', NaN, 'interp', interp);
if  contains(lastwarn, 'Resulting registration could be poor')
    score(3) = 0;
else
    [eval_reg,eval_fixed,~] = postcropping(RegisteredImage{3},FIXED);
    score(3) = ssim(eval_reg, eval_fixed);
end
lastwarn("");

% (4) Phase correlation + mono
tformMono_PC= imregtform(MOVING,movingRefObj,FIXED,fixedRefObj,'rigid',optimizerMono,metricMono,'PyramidLevels',1,'InitialTransformation',tformPhaseCorr);
transformation{4} = tformMono_PC;
RegisteredImage{4} = imwarp(MOVING, movingRefObj, tformMono_PC, 'OutputView', fixedRefObj, 'SmoothEdges', true, 'FillValues', NaN, 'interp', interp);
if  contains(lastwarn, 'Resulting registration could be poor')
    score(4) = 0;
else
    [eval_reg,eval_fixed,~] = postcropping(RegisteredImage{4},FIXED);
    score(4) = ssim(eval_reg, eval_fixed);
end
lastwarn("");

% (5) Phase correlation + multi
tformMulti_PC= imregtform(MOVING,movingRefObj,FIXED,fixedRefObj,'rigid',optimizerMulti,metricMulti,'PyramidLevels',1,'InitialTransformation',tformPhaseCorr);
transformation{5} = tformMulti_PC;
RegisteredImage{5} = imwarp(MOVING, movingRefObj, tformMono_PC, 'OutputView', fixedRefObj, 'SmoothEdges', true, 'FillValues', NaN, 'interp', interp);
if  contains(lastwarn, 'Resulting registration could be poor')
    score(5) = 0;
else
    [eval_reg,eval_fixed,~] = postcropping(RegisteredImage{5},FIXED);
    score(5) = ssim(eval_reg, eval_fixed);
end
lastwarn("");

[regScore, regMethodIndx] = max(score);

MOVINGREG.transformation = transformation{regMethodIndx};
MOVINGREG.RegisteredImage = RegisteredImage{regMethodIndx};
MOVINGREG.SpatialRefObj = fixedRefObj;

Methods = {'PhaseCorrelation', 'Monomodal', 'Multimodal','PhaseCorr+Monomodal','PhaseCorr+Multimodal'};
regMethod = Methods(regMethodIndx);
end

